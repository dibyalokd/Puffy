import subprocess

def upload_safe(filename, repo_url):
    try:
        # 1. Stage and Commit your file locally
        subprocess.run(["git", "add", filename], check=True)
        subprocess.run(["git", "commit", "-m", "Updating file"], check=True)

        # 2. Pull the remote changes
        # '--rebase' keeps your history clean by putting your commit on top
        print("Pulling remote changes...")
        subprocess.run(["git", "pull", "origin", "master", "--rebase"], check=True)

        # 3. Now push
        subprocess.run(["git", "push", "origin", "master"], check=True)
        print("Upload successful!")

    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")


----------


def reset_and_upload(file_path, repo_url):
    # Force Git to 'forget' the old URL and use the new one provided
    subprocess.run(["git", "remote", "remove", "origin"], capture_output=True)
    subprocess.run(["git", "remote", "add", "origin", repo_url], check=True)
    
    # Now proceed with add, commit, push...
    subprocess.run(["git", "push", "-u", "origin", "master"], check=True)


------

import subprocess
import sys

def upload_single_file(filename, repo_url, commit_msg="Update file via script"):
    try:
        # 1. Ensure we are in a git repo
        subprocess.run(["git", "init"], check=False) # Won't hurt if already init'd
        
        # 2. Specifically stage the file (using -f to ensure it's not ignored)
        print(f"Staging {filename}...")
        subprocess.run(["git", "add", "-f", filename], check=True)

        # 3. Commit - we use a check to see if there's actually something to commit
        # to avoid the "nothing to commit" error
        status = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True).stdout
        if filename in status or "M" in status or "A" in status:
            subprocess.run(["git", "commit", "-m", commit_msg], check=True)
            print("Commit successful.")
        else:
            print("No changes detected in the file. Skipping commit.")
            return

        # 4. Push specifically to master
        print("Pushing to Bitbucket master...")
        subprocess.run(["git", "push", "origin", "master"], check=True)
        
        print("Done! File is live on Bitbucket.")

    except subprocess.CalledProcessError as e:
        print(f"Git command failed: {e}")
        if e.stderr:
            print(f"Error details: {e.stderr}")

# Usage
upload_single_file("your_filename_here.ext", "your_bitbucket_url_here")


-----

import subprocess
import os

def upload_to_bitbucket(file_path, repo_url, commit_message):
    """
    Uploads a specific file to the master branch of a Bitbucket repo.
    """
    try:
        # 1. Initialize git if not already a repo
        if not os.path.exists(".git"):
            subprocess.run(["git", "init"], check=True)
            subprocess.run(["git", "remote", "add", "origin", repo_url], check=True)

        # 2. Add the specific file
        subprocess.run(["git", "add", file_path], check=True)

        # 3. Commit the changes
        subprocess.run(["git", "commit", "-m", commit_message], check=True)

        # 4. Push to 'master'
        # We use -u to set upstream, and 'master' as requested
        result = subprocess.run(["git", "push", "-u", "origin", "master"], 
                                capture_output=True, text=True, check=True)
        
        print("Success! File uploaded to master branch.")
        print(result.stdout)

    except subprocess.CalledProcessError as e:
        print(f"Error during Git execution: {e.stderr}")

# --- Configuration ---
FILE_TO_UPLOAD = "your_file.txt"
BITBUCKET_URL = "https://username@bitbucket.org/workspace/repo.git"
MSG = "Add automated file via Python subprocess"

# Execute
upload_to_bitbucket(FILE_TO_UPLOAD, BITBUCKET_URL, MSG)
